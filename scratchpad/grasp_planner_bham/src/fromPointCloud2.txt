template <typename PointT> void
167  fromPCLPointCloud2 (const pcl::PCLPointCloud2& msg, pcl::PointCloud<PointT>& cloud,
168  const MsgFieldMap& field_map)
169  {
170  // Copy info fields
171  cloud.header = msg.header;
172  cloud.width = msg.width;
173  cloud.height = msg.height;
174  cloud.is_dense = msg.is_dense == 1;
175 
176  // Copy point data
177  uint32_t num_points = msg.width * msg.height;
178  cloud.points.resize (num_points);
179  uint8_t* cloud_data = reinterpret_cast<uint8_t*>(&cloud.points[0]);
180 
181  // Check if we can copy adjacent points in a single memcpy
182  if (field_map.size() == 1 &&
183  field_map[0].serialized_offset == 0 &&
184  field_map[0].struct_offset == 0 &&
185  msg.point_step == sizeof(PointT))
186  {
187  uint32_t cloud_row_step = static_cast<uint32_t> (sizeof (PointT) * cloud.width);
188  const uint8_t* msg_data = &msg.data[0];
189  // Should usually be able to copy all rows at once
190  if (msg.row_step == cloud_row_step)
191  {
192  memcpy (cloud_data, msg_data, msg.data.size ());
193  }
194  else
195  {
196  for (uint32_t i = 0; i < msg.height; ++i, cloud_data += cloud_row_step, msg_data += msg.row_step)
197  memcpy (cloud_data, msg_data, cloud_row_step);
198  }
199 
200  }
201  else
202  {
203  // If not, memcpy each group of contiguous fields separately
204  for (uint32_t row = 0; row < msg.height; ++row)
205  {
206  const uint8_t* row_data = &msg.data[row * msg.row_step];
207  for (uint32_t col = 0; col < msg.width; ++col)
208  {
209  const uint8_t* msg_data = row_data + col * msg.point_step;
210  BOOST_FOREACH (const detail::FieldMapping& mapping, field_map)
211  {
212  memcpy (cloud_data + mapping.struct_offset, msg_data + mapping.serialized_offset, mapping.size);
213  }
214  cloud_data += sizeof (PointT);
215  }
216  }
217  }
218  }
